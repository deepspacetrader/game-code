import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import getAsciiImage from 'get-ascii-image';
import Particles from 'react-particles';
import { loadSlim } from 'tsparticles-slim';
import './AsciiWaveAnimator.scss';

// Define the character set from darkest to brightest for the animation
const ANIMATION_ASCII_CHARS = [' ', '.', ':', ';', '=', '*', '#', '@'];
const MAX_BRIGHTNESS_INDEX = ANIMATION_ASCII_CHARS.length - 1;

// This mapping helps translate characters from the initial ASCII art
// (generated by get-ascii-image) to a numerical brightness index for the wave
const ORIGINAL_IMAGE_TO_ASCII_CHARS = ' .,:;oahkbdpqwWmAEGRTYFHUJOX';
const charToOriginalBrightnessIndex = {};
ORIGINAL_IMAGE_TO_ASCII_CHARS.split('').forEach((char, index) => {
    charToOriginalBrightnessIndex[char] = index;
});

const getMappedBrightnessIndex = (originalChar) => {
    const originalIndex = charToOriginalBrightnessIndex[originalChar];
    if (originalIndex === undefined) {
        return 0; // Fallback for characters not in the predefined set
    }
    const normalizedOriginal = originalIndex / (ORIGINAL_IMAGE_TO_ASCII_CHARS.length - 1);
    return Math.round(normalizedOriginal * MAX_BRIGHTNESS_INDEX);
};

const AsciiWaveAnimator = ({
    imagePath,
    isScanning = false,
    initialScanComplete = false,
    showFinalResult = false,
    isThumbnail = false,
    scanProgress = 0,
    onScanComplete, // Callback when scan is successfully completed
    onScanFail, // Callback when scan fails
}) => {
    const [scanComplete, setScanComplete] = useState(initialScanComplete);
    const [scanSuccess, setScanSuccess] = useState(false);
    const [scanFailed, setScanFailed] = useState(false);

    // Particle effects initialization
    const particlesInit = useCallback(async (engine) => {
        await loadSlim(engine);
    }, []);

    const particlesLoaded = useCallback(async (container) => {
        // Optional: Do something when particles are loaded
    }, []);

    // Refs
    const containerRef = useRef(null);
    const animationFrameRef = useRef(null);
    const frameCountRef = useRef(0);
    const scanStartTimeRef = useRef(0);
    const mousePositionRef = useRef({
        x: 0,
        y: 0,
        startX: 0,
        startY: 0,
        isScanning: false,
        progressX: 0,
        progressY: 0,
    });

    // State
    const [initialAsciiArt, setInitialAsciiArt] = useState(null);
    const [animatedAsciiArt, setAnimatedAsciiArt] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [scanStroke, setScanStroke] = useState([]);
    const [mousePosition, setMousePosition] = useState({
        x: 0,
        y: 0,
        startX: 0,
        startY: 0,
        isScanning: false,
        progressX: 0,
        progressY: 0,
    });

    // Animation parameters with dynamic variance
    const [waveParams, setWaveParams] = useState({
        frequency: 4.269,
        speed: 0.07,
        amplitude: 1.1337,
        targetFrequency: 4.269,
        targetSpeed: 0.07,
        targetAmplitude: 1.1337,
    });

    // Update wave parameters over time for dynamic animation
    useEffect(() => {
        if (!isScanning) return;

        let animationFrameId;

        const updateParams = () => {
            setWaveParams((prev) => {
                // Only update targets occasionally
                if (Math.random() < 0.005) {
                    // ~0.5% chance per frame to change targets
                    return {
                        ...prev,
                        //targetFrequency: 3 + Math.random() * 3, // 3-6
                        // targetSpeed: 0.03 + Math.random() * 0.08, // 0.03-0.11
                        targetAmplitude: 6.9 + Math.random() * 0.42, // 0.8-1.6
                    };
                }
                return prev;
            });
        };

        const animate = () => {
            updateParams();

            // Smoothly interpolate towards target values
            setWaveParams((prev) => ({
                ...prev,
                frequency: prev.frequency + (prev.targetFrequency - prev.frequency) * 0.01,
                speed: prev.speed + (prev.targetSpeed - prev.speed) * 0.01,
                amplitude: prev.amplitude + (prev.targetAmplitude - prev.amplitude) * 0.01,
            }));

            animationFrameId = requestAnimationFrame(animate);
        };

        animationFrameId = requestAnimationFrame(animate);
        return () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };
    }, [isScanning]);

    const SCAN_BAR_COLOR = '#00ff00';
    const SCAN_POINT_SIZE = 20; // Size of the clickable scan points

    // Scan directions - memoized to prevent unnecessary re-renders
    const DIRECTIONS = useMemo(
        () => ({
            TOP_LEFT_TO_BOTTOM_RIGHT: 'top-left-to-bottom-right',
            TOP_RIGHT_TO_BOTTOM_LEFT: 'top-right-to-bottom-left',
        }),
        []
    );

    // State for scan direction and progress
    const [scanDirection, setScanDirection] = useState(null);
    const [startPoint, setStartPoint] = useState(null);
    const [currentPoint, setCurrentPoint] = useState(null);
    const [isCorrectDirection, setIsCorrectDirection] = useState(true);

    // Initialize scan direction when scanning starts
    useEffect(() => {
        if (isScanning && !scanComplete) {
            // Reset states when starting a new scan
            setScanFailed?.(false);
            setScanSuccess?.(false);
            frameCountRef.current = 0;

            // Only set a new direction if we don't have one
            if (!scanDirection) {
                const directions = Object.values(DIRECTIONS);
                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                setScanDirection(randomDirection);
            }
        }
    }, [isScanning, scanComplete, scanDirection, DIRECTIONS]);

    // Reset function to clean up all states
    const resetScan = useCallback(() => {
        setScanDirection(null);
        setStartPoint(null);
        setCurrentPoint(null);
        setIsCorrectDirection(true);
        setScanFailed(false);
        setScanSuccess(false);
        frameCountRef.current = 0;

        // Reset wave parameters to initial values
        setWaveParams({
            frequency: 4.269,
            speed: 0.07,
            amplitude: 1.1337,
            targetFrequency: 4.269,
            targetSpeed: 0.07,
            targetAmplitude: 1.1337,
        });
    }, []);

    // Reset state when scanning is done or when isScanning changes
    useEffect(() => {
        if (!isScanning) {
            resetScan();
        }
    }, [isScanning, resetScan]);

    // Get the expected start and end points based on scan direction
    const getExpectedPoints = useCallback(
        (direction) => {
            switch (direction) {
                case DIRECTIONS.TOP_LEFT_TO_BOTTOM_RIGHT:
                    return {
                        start: { x: 0, y: 0 },
                        end: { x: 1, y: 1 },
                    };
                case DIRECTIONS.TOP_RIGHT_TO_BOTTOM_LEFT:
                    return {
                        start: { x: 1, y: 0 },
                        end: { x: 0, y: 1 },
                    };
                default:
                    return { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } };
            }
        },
        [DIRECTIONS.TOP_LEFT_TO_BOTTOM_RIGHT, DIRECTIONS.TOP_RIGHT_TO_BOTTOM_LEFT]
    );

    // Check if point is near the start area
    const isNearStartPoint = useCallback((point, start) => {
        if (!start) return false;
        const distance = Math.sqrt(Math.pow(point.x - start.x, 2) + Math.pow(point.y - start.y, 2));
        return distance < 0.95; // 15% of container size
    }, []);

    // Check if point is near the end area
    const isNearEndPoint = useCallback((point, end) => {
        if (!end) return false;
        const distance = Math.sqrt(Math.pow(point.x - end.x, 2) + Math.pow(point.y - end.y, 2));
        return distance < 0.15; // 15% of container size
    }, []);

    // Check if movement is in correct direction
    const isMovingInCorrectDirection = useCallback(
        (start, current, direction) => {
            if (!start || !current) return true;

            const dx = current.x - start.x;
            const dy = current.y - start.y;

            // Check if moving in the general direction
            switch (direction) {
                case DIRECTIONS.TOP_LEFT_TO_BOTTOM_RIGHT:
                    return dx > 0 && dy > 0;
                case DIRECTIONS.TOP_RIGHT_TO_BOTTOM_LEFT:
                    return dx < 0 && dy > 0;
                default:
                    return true;
            }
        },
        [DIRECTIONS]
    );

    // Handle starting the scan from the start point
    const startScan = useCallback(
        (startX, startY) => {
            if (!isScanning || scanComplete || !containerRef.current || !scanDirection) {
                console.log('Cannot start scan - invalid state');
                return;
            }

            console.log('Starting scan from:', { startX, startY });
            const point = { x: startX, y: startY };
            setStartPoint(point);
            setCurrentPoint(point);
            setScanFailed(false);
            setScanSuccess(false);
            setIsCorrectDirection(true);

            // Set initial mouse position in both ref and state
            const rect = containerRef.current.getBoundingClientRect();
            const newPos = {
                x: startX * rect.width,
                y: startY * rect.height,
                startX: startX * rect.width,
                startY: startY * rect.height,
                isScanning: true,
                progressX: 0,
                progressY: 0,
            };
            Object.assign(mousePositionRef.current, newPos);
            setMousePosition(newPos);
        },
        [isScanning, scanComplete, scanDirection, containerRef]
    );

    // Unified mouse down handler
    const handleMouseDown = useCallback(
        (e) => {
            // Allow middle mouse button to work for scrolling
            if (e.button === 1) return false;

            // Only handle left mouse button
            if (e.button !== 0) return false;

            if (!isScanning || scanComplete || !containerRef.current || !scanDirection) {
                return false;
            }

            e.stopPropagation();
            e.preventDefault();

            const containerRect = containerRef.current.getBoundingClientRect();
            const x = (e.clientX - containerRect.left) / containerRect.width;
            const y = (e.clientY - containerRect.top) / containerRect.height;
            const point = { x, y };

            const expectedPoints = getExpectedPoints(scanDirection);
            const nearStartPoint = isNearStartPoint(point, expectedPoints.start);

            // Only allow starting scan from the start point
            if (nearStartPoint) {
                // Start scanning from the start point
                startScan(expectedPoints.start.x, expectedPoints.start.y);

                // Update current point to the actual click position for smoother start
                setCurrentPoint(point);

                // Store the start time for scan duration calculation
                scanStartTimeRef.current = Date.now();

                // Prevent text selection during drag
                document.body.style.userSelect = 'none';

                // Set initial stroke
                setScanStroke([point]);

                return true;
            }

            return false;
        },
        [isScanning, scanComplete, scanDirection, startScan, isNearStartPoint, getExpectedPoints]
    );

    // Unified mouse move handler
    const handleMouseMove = useCallback(
        (e) => {
            if (!isScanning || !startPoint || !containerRef.current) return;

            e.stopPropagation();

            const rect = containerRef.current.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            const point = { x, y };

            // Update mouse position ref for animation
            if (mousePositionRef.current) {
                mousePositionRef.current = {
                    ...mousePositionRef.current,
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    progressX: x,
                    progressY: y,
                    isScanning: true,
                };
                setMousePosition(mousePositionRef.current);
            }

            // Update current point
            setCurrentPoint(point);

            // Update stroke
            setScanStroke((prevStroke) => [...prevStroke, point]);

            // Check if we've reached the end point
            const expectedPoints = getExpectedPoints(scanDirection);
            const distanceToEnd = Math.hypot(x - expectedPoints.end.x, y - expectedPoints.end.y);

            if (distanceToEnd < 0.05) {
                // Within 5% of end point
                const scanTime = (Date.now() - scanStartTimeRef.current) / 1000;
                setScanComplete(true);
                setScanSuccess(true);
                if (onScanComplete) {
                    onScanComplete(scanTime);
                }
            }
        },
        [isScanning, startPoint, scanDirection, onScanComplete, getExpectedPoints]
    );

    // Unified mouse up handler
    const handleMouseUp = useCallback(
        (e) => {
            // Only handle left mouse button
            if (e && e.button !== 0) return;

            // Only process if we were scanning
            if (!isScanning || !startPoint || !currentPoint) return;

            const expectedPoints = getExpectedPoints(scanDirection);
            const isAtEndPoint = isNearEndPoint(currentPoint, expectedPoints.end);

            // If we have a valid scan in progress
            if (mousePositionRef.current?.isScanning) {
                // If not already completed and not at end point, fail the scan
                if (!isAtEndPoint && !scanFailed && !scanSuccess) {
                    setScanFailed(true);
                    if (onScanFail) onScanFail();
                } else if (isAtEndPoint && !scanFailed && !scanSuccess) {
                    setScanSuccess(true);
                    setScanComplete(true);
                    const scanTime = (Date.now() - scanStartTimeRef.current) / 1000;
                    if (onScanComplete) onScanComplete(scanTime);
                }
            }

            // Reset scanning state
            if (mousePositionRef.current) {
                mousePositionRef.current.isScanning = false;
            }

            // Clean up
            document.body.style.userSelect = '';
        },
        [
            isScanning,
            startPoint,
            currentPoint,
            scanFailed,
            scanSuccess,
            scanDirection,
            onScanFail,
            onScanComplete,
            getExpectedPoints,
            isNearEndPoint,
        ]
    );

    // Handle mouse leave
    const handleMouseLeave = useCallback(() => {
        if (isScanning && startPoint && !scanSuccess) {
            setScanFailed(true);
            if (onScanFail) onScanFail();

            // Reset scanning state
            if (mousePositionRef.current) {
                mousePositionRef.current.isScanning = false;
            }

            // Clean up
            document.body.style.userSelect = '';
        }
    }, [isScanning, startPoint, scanSuccess, onScanFail]);

    // Add/remove mouse event listeners
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        if (isScanning && !scanComplete) {
            container.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            container.addEventListener('mouseleave', handleMouseLeave);
        }

        return () => {
            container.removeEventListener('mousedown', handleMouseDown);
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            container.removeEventListener('mouseleave', handleMouseLeave);
        };
    }, [
        isScanning,
        scanComplete,
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleMouseLeave,
    ]);

    // Convert image to ASCII
    useEffect(() => {
        const convertImage = async () => {
            if (!imagePath) return;

            setIsLoading(true);
            try {
                const config = {
                    width: 200,
                    height: 200,
                    maxHeight: 200,
                    maxWidth: 200,
                    pixelWidth: 5,
                    pixelHeight: 5,
                    contrast: 1.2,
                    chars: ' .,:;=*#@+-><!~`^0987654321qwertyuiop[]asdfghjkl;zxcvbnm,./',
                };
                const ascii = await getAsciiImage(imagePath, config);
                setInitialAsciiArt(ascii);
                setAnimatedAsciiArt(ascii);
            } catch (error) {
                console.error('Error converting image to ASCII:', error);
                setAnimatedAsciiArt('Failed to load ASCII art. Check console for errors.');
            } finally {
                setIsLoading(false);
            }
        };

        if (imagePath) {
            convertImage();
        }
    }, [imagePath]);

    // Memoize the brightness map for each character in the ASCII art
    const brightnessMap = useMemo(() => {
        if (!initialAsciiArt) return [];
        return initialAsciiArt
            .split('\n')
            .map((line) => line.split('').map((char) => getMappedBrightnessIndex(char)));
    }, [initialAsciiArt]);

    // Calculate animated ASCII art based on mouse position and scan progress
    const calculateAnimatedArt = useCallback(
        (frame) => {
            if (!initialAsciiArt) return 'Loading ASCII Art...';

            // For thumbnails or when showing final result, return the original art
            if (isThumbnail || (scanComplete && showFinalResult)) {
                return initialAsciiArt;
            }

            const totalRows = brightnessMap.length;
            if (totalRows === 0) return '';
            const totalCols = brightnessMap[0].length;
            const currentMousePos = mousePositionRef.current;

            // If we have mouse position and we're scanning, create a wave effect from the mouse position
            if (
                isScanning &&
                !scanComplete &&
                currentMousePos.x > 0 &&
                currentMousePos.y > 0 &&
                containerRef.current
            ) {
                return brightnessMap
                    .map((row, rowIndex) =>
                        row
                            .map((brightness, colIndex) => {
                                const dx =
                                    colIndex / totalCols -
                                    currentMousePos.x / containerRef.current.offsetWidth;
                                const dy =
                                    rowIndex / totalRows -
                                    currentMousePos.y / containerRef.current.offsetHeight;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const waveValue =
                                    Math.sin(distance * 20 - frame * waveParams.speed * 2) *
                                    waveParams.amplitude;
                                const newIdx = Math.max(
                                    0,
                                    Math.min(
                                        MAX_BRIGHTNESS_INDEX,
                                        Math.round(brightness + waveValue)
                                    )
                                );
                                return ANIMATION_ASCII_CHARS[newIdx];
                            })
                            .join('')
                    )
                    .join('\n');
            }

            // Default wave animation when not scanning
            const result = [];
            for (let rowIndex = 0; rowIndex < totalRows; rowIndex++) {
                const row = brightnessMap[rowIndex];
                const waveValue =
                    Math.sin(
                        (rowIndex / totalRows) * Math.PI * waveParams.frequency +
                            frame * waveParams.speed
                    ) * waveParams.amplitude;

                let line = '';
                for (let colIndex = 0; colIndex < row.length; colIndex++) {
                    const brightness = row[colIndex];
                    const newIdx = Math.max(
                        0,
                        Math.min(MAX_BRIGHTNESS_INDEX, Math.round(brightness + waveValue))
                    );
                    line += ANIMATION_ASCII_CHARS[newIdx];
                }
                result.push(line);
            }
            return result.join('\n');
        },
        [
            initialAsciiArt,
            isThumbnail,
            scanComplete,
            showFinalResult,
            brightnessMap,
            isScanning,
            mousePosition.x,
            mousePosition.y,
            waveParams.amplitude,
            waveParams.frequency,
            waveParams.speed,
            containerRef,
        ]
    );

    useEffect(() => {
        // Only start animation if initial ASCII art is available
        if (!initialAsciiArt) {
            setAnimatedAsciiArt('Loading ASCII Art...');
            return;
        }

        let animationId;
        let shouldAnimate = true;
        let lastFrameTime = 0;
        const frameDuration = 1000 / 30; // Target 30 FPS

        const animate = (timestamp) => {
            if (!shouldAnimate) return;

            // Throttle the frame rate
            if (timestamp - lastFrameTime >= frameDuration) {
                lastFrameTime = timestamp;
                frameCountRef.current += 1;

                // Calculate the new frame
                const newFrame = calculateAnimatedArt(frameCountRef.current);
                setAnimatedAsciiArt(newFrame);
            }

            animationId = requestAnimationFrame(animate);
        };

        // Start the animation loop
        animationId = requestAnimationFrame(animate);

        // Cleanup function: cancel the animation frame when the component unmounts
        return () => {
            shouldAnimate = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        };
    }, [initialAsciiArt]); // Only depend on initialAsciiArt, calculateAnimatedArt is stable

    // --- RENDER ---
    // Don't render anything while loading if we don't have content yet
    if (isLoading || !initialAsciiArt) {
        return <div className="loading-placeholder">Loading ASCII Art...</div>;
    }

    const asciiContent = isThumbnail ? (
        <div
            className="ascii-art"
            style={{
                filter: 'invert(1)',
                margin: 0,
                padding: '5px',
                lineHeight: 1,
                fontSize: '8px',
                fontFamily: 'monospace',
                whiteSpace: 'pre',
                textAlign: 'left',
                backgroundColor: 'black',
                color: 'white',
                width: '100%',
                height: '100%',
                // overflow: 'hidden',
            }}
            dangerouslySetInnerHTML={{
                __html: animatedAsciiArt.replace(/\n/g, '<br/>'),
            }}
        />
    ) : (
        <div
            style={{
                margin: 'auto',
                padding: '20px',
                lineHeight: 1,
                fontSize: '8px',
                fontFamily: 'monospace',
                whiteSpace: 'pre',
                textAlign: 'center',
                backgroundColor: '#000',
                color: '#fff',
                minWidth: '100%',
                minHeight: '100%',
                display: 'inline-block',
                flexShrink: 0,
            }}
        >
            {animatedAsciiArt}
        </div>
    );

    // For main scanner view
    return (
        <div
            className={`ascii-wave-container ${isThumbnail ? 'thumbnail' : ''}`}
            style={{
                position: 'relative',
                width: '100%',
                height: '100%',
                overflow: 'auto',
                backgroundColor: '#000',
                cursor: isScanning && !scanComplete ? 'crosshair' : 'default',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
            }}
            ref={containerRef}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
        >
            {/* ASCII Content */}
            <div
                className="ascii-wave-animator"
                style={{
                    position: 'relative',
                    display: 'inline-block',
                    minWidth: 'fit-content',
                    minHeight: 'fit-content',
                }}
            >
                {asciiContent}

                {/* Start and End Points - Positioned at the corners of the ASCII content */}
                {isScanning && !scanComplete && !isThumbnail && scanDirection && (
                    <>
                        {/* Start Point */}
                        <div
                            className="scan-point start-point"
                            style={{
                                position: 'absolute',
                                left: 0,
                                top: 0,
                                width: `${SCAN_POINT_SIZE}px`,
                                height: `${SCAN_POINT_SIZE}px`,
                                backgroundColor: 'rgba(0, 255, 0, 0.3)',
                                border: `2px solid ${SCAN_BAR_COLOR}`,
                                borderRadius: '50%',
                                transform: 'translate(-50%, -50%)',
                                cursor: !startPoint ? 'pointer' : 'default',
                                boxShadow: '0 0 10px rgba(0, 255, 0, 0.5)',
                                transition: 'all 0.2s',
                                pointerEvents: !startPoint ? 'auto' : 'none',
                                opacity: !startPoint ? 1 : 0.5,
                                zIndex: 20,
                            }}
                            onMouseDown={(e) => {
                                e.stopPropagation();
                                startScan(0, 0);
                            }}
                        />

                        {/* End Point */}
                        <div
                            className="scan-point end-point"
                            style={{
                                position: 'absolute',
                                right: 0,
                                bottom: 0,
                                width: `${SCAN_POINT_SIZE}px`,
                                height: `${SCAN_POINT_SIZE}px`,
                                backgroundColor: 'rgba(0, 255, 0, 0.3)',
                                border: `2px solid ${SCAN_BAR_COLOR}`,
                                borderRadius: '50%',
                                transform: 'translate(50%, 50%)',
                                cursor: !startPoint ? 'pointer' : 'default',
                                boxShadow: '0 0 10px rgba(0, 255, 0, 0.5)',
                                transition: 'all 0.2s',
                                pointerEvents: !startPoint ? 'auto' : 'none',
                                opacity: !startPoint ? 1 : 0.5,
                                zIndex: 20,
                            }}
                            onMouseDown={(e) => {
                                e.stopPropagation();
                                startScan(1, 1);
                            }}
                        />
                    </>
                )}
                {/* Scan Line */}
                {isScanning && !scanComplete && startPoint && currentPoint && (
                    <div
                        className="scan-line"
                        style={{
                            position: 'absolute',
                            left: `${startPoint.x * 100}%`,
                            top: `${startPoint.y * 100}%`,
                            width: `${Math.max(
                                2,
                                Math.hypot(
                                    (currentPoint.x - startPoint.x) * 100,
                                    (currentPoint.y - startPoint.y) * 100
                                )
                            )}%`,
                            height: '2px',
                            backgroundColor: isCorrectDirection ? SCAN_BAR_COLOR : '#ff0000',
                            transform: `rotate(${Math.atan2(
                                (currentPoint.y - startPoint.y) * 100,
                                (currentPoint.x - startPoint.x) * 100
                            )}rad)`,
                            transformOrigin: 'left center',
                            pointerEvents: 'none',
                            zIndex: 10,
                        }}
                    />
                )}
            </div>
            {/* Scan Instructions */}
            {isScanning && !scanComplete && !isThumbnail && !startPoint && (
                <div
                    className="instruction-text"
                    style={{
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        color: SCAN_BAR_COLOR,
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        padding: '10px 20px',
                        borderRadius: '4px',
                        textAlign: 'center',
                        pointerEvents: 'none',
                        zIndex: 30,
                    }}
                >
                    Click on a green dot and drag to the other dot
                </div>
            )}
            {/* Scanner Particles - Success */}
            {scanSuccess && (
                <Particles
                    id="tsparticles-success"
                    init={particlesInit}
                    loaded={particlesLoaded}
                    options={{
                        particles: {
                            number: {
                                value: 50,
                                density: { enable: true, value_area: 800 },
                            },
                            color: { value: ['#4FC3F7', '#29B6F6', '#03A9F4'] },
                            shape: { type: 'circle' },
                            opacity: { value: 0.9, random: true },
                            size: { value: 2, random: true },
                            move: {
                                enable: true,
                                speed: 3,
                                direction: 'none',
                                random: false,
                                straight: false,
                                outModes: { default: 'bounce' },
                            },
                            links: {
                                enable: true,
                                distance: 150,
                                color: '#4FC3F7',
                                opacity: 0.4,
                                width: 1,
                            },
                        },
                        interactivity: {
                            detectsOn: 'window',
                            events: {
                                onHover: { enable: true, mode: 'connect' },
                                resize: true,
                            },
                            modes: {
                                connect: {
                                    distance: 80,
                                    links: { opacity: 0.5 },
                                },
                            },
                        },
                        fullScreen: { enable: false, zIndex: 5 },
                        detectRetina: true,
                        background: { color: 'transparent' },
                        fpsLimit: 60,
                    }}
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        zIndex: 5,
                    }}
                />
            )}
            {/* DEBUG PARTICLES */}
            {/* <Particles
                className="scanner-particles"
                id="tsparticles-failure"
                init={particlesInit}
                loaded={particlesLoaded}
                options={{
                    particles: {
                        number: {
                            value: 150,
                            density: { enable: true, value_area: 1500 },
                        },
                        color: { value: ['#fff', '#999', '#888'] },
                        shape: { type: 'circle' },
                        opacity: { value: 1, random: true },
                        size: { value: 1.337, random: false },
                        move: {
                            enable: true,
                            speed: 13.37,
                            direction: 'none',
                            random: true,
                            straight: true,
                            outModes: { default: 'out' },
                        },
                    },
                    interactivity: {
                        detectsOn: 'window',
                        events: {
                            onHover: { enable: true, mode: 'connect' },
                            resize: true,
                        },
                        modes: {
                            // repulse: { distance: 100, duration: 0.4 },
                            connect: { distance: 23, radius: 290 },
                            // push: { quantity: 5 },
                            // bubble: { distance: 35, size: 42, duration: 1.2 },
                        },
                    },
                    fullScreen: { enable: false, zIndex: 5 },
                    detectRetina: true,
                    background: { color: 'transparent' },
                    fpsLimit: 60,
                }}
                style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: '100%',
                    zIndex: 5,
                }}
            /> */}
            {/* Failure Particle Effect */}
            {scanFailed && (
                <Particles
                    id="tsparticles-failure2"
                    init={particlesInit}
                    loaded={particlesLoaded}
                    options={{
                        particles: {
                            number: {
                                value: 60,
                                density: { enable: true, value_area: 800 },
                            },
                            color: { value: ['#8B4513', '#A0522D', '#CD853F'] },
                            shape: { type: 'circle' },
                            opacity: { value: 0.8, random: true },
                            size: { value: 3, random: true },
                            move: {
                                enable: true,
                                speed: 2,
                                direction: 'none',
                                random: true,
                                straight: false,
                                outModes: { default: 'out' },
                            },
                        },
                        interactivity: {
                            detectsOn: 'window',
                            events: {
                                onHover: { enable: true, mode: 'repulse' },
                                resize: true,
                            },
                            modes: {
                                repulse: { distance: 100, duration: 0.4 },
                            },
                        },
                        fullScreen: { enable: false, zIndex: 5 },
                        detectRetina: true,
                        background: { color: 'transparent' },
                        fpsLimit: 60,
                    }}
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        zIndex: 5,
                    }}
                />
            )}
            {/* Scan failed message */}
            {isScanning && !isThumbnail && scanFailed && (
                <div
                    className="scan-failed"
                    style={{
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        color: '#ff0000',
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        padding: '20px',
                        borderRadius: '4px',
                        textAlign: 'center',
                        zIndex: 100,
                    }}
                >
                    Scan Failed!
                    <br />
                    <button
                        onClick={() => {
                            setScanFailed(false);
                            setStartPoint(null);
                            setCurrentPoint(null);
                        }}
                        style={{
                            marginTop: '10px',
                            padding: '5px 15px',
                            backgroundColor: '#333',
                            color: '#fff',
                            border: '1px solid #ff0000',
                            borderRadius: '4px',
                            cursor: 'pointer',
                        }}
                    >
                        Try Again
                    </button>
                </div>
            )}
            {/* Scan success message */}
            {isScanning && !isThumbnail && scanSuccess && (
                <div
                    className="scan-success"
                    style={{
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        color: SCAN_BAR_COLOR,
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        padding: '20px',
                        borderRadius: '4px',
                        textAlign: 'center',
                        zIndex: 100,
                    }}
                >
                    Scan Complete!
                </div>
            )}
            ;
        </div>
    );
};

export default AsciiWaveAnimator;
